<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Neon Slime Jump - Annotated</title>
    <!-- 
        GAME DESCRIPTION:
        This is an endless jumper game set in a dark, deep-space environment.
        The player controls a "Cyber-Artifact" (a geometric glowing core inside a cage).
        
        MECHANICS:
        - Gravity pulls the player down constanty.
        - Tapping Left or Right imparts an upward and lateral force (Jump).
        - The goal is to climb as high as possible without hitting neon obstacles or falling off the bottom.
        - Score increases as you ascend.
        
        TECH STACK:
        - Rendering: Three.js (WebGL)
        - Post-Processing: UnrealBloomPass for the neon glow effect.
        - Audio: Web Audio API (Procedurally generated sounds, no external files).
        - Styling: Custom Shaders (GLSL) for the background and player core.
    -->
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Courier New', Courier, monospace; 
            background: #000;
            touch-action: none; /* Prevents zooming/scrolling on mobile */
            user-select: none;
            -webkit-user-select: none;
        }
        
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI OVERLAY */
        #ui {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
            z-index: 10;
        }
        
        #score {
            position: absolute;
            top: 10%;
            font-size: 100px;
            color: rgba(255,255,255,0.1);
            font-weight: 900;
            transition: transform 0.1s;
            mix-blend-mode: screen;
        }
        
        #start-text {
            font-size: 24px;
            color: #fff;
            background: rgba(0,0,0,0.8);
            border: 1px solid #0ff;
            padding: 30px;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.15);
            animation: blink 2s infinite;
            pointer-events: auto; /* Needs to be clickable */
            cursor: pointer;
        }
        
        .controls-hint {
            position: absolute;
            bottom: 40px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 50px;
            box-sizing: border-box;
            opacity: 0.4;
            font-weight: bold;
            color: #fff;
            font-size: 12px;
            letter-spacing: 2px;
        }
        
        @keyframes blink {
            0%, 100% { border-color: #0ff; opacity: 1; }
            50% { border-color: #f0f; opacity: 0.6; }
        }
    </style>
</head>
<body>

<div id="ui">
    <div id="score">0</div>
    <div id="start-text" onclick="triggerStart()">Initialize Sequence</div>
    <div class="controls-hint">
        <span>&larr; PORT</span>
        <span>STARBOARD &rarr;</span>
    </div>
</div>
<div id="canvas-container"></div>

<!-- Import Three.js and Post Processing libraries from CDN -->
<script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // --- AUDIO SYSTEM (Procedural) ---
    // Uses the Web Audio API to generate sounds on the fly.
    // This avoids loading external MP3s and allows for dynamic sound modification.
    const Audio = {
        ctx: null,
        init: function() {
            // Initialize AudioContext on first user interaction (browser policy)
            if (!this.ctx) {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (this.ctx.state === 'suspended') {
                this.ctx.resume();
            }
        },
        
        // Sound: "Crash"
        // A filtered white noise burst that sweeps down in pitch.
        // Used when the player hits an obstacle.
        crash: function() {
            if (!this.ctx) return;
            const t = this.ctx.currentTime;
            
            // 1. Create a buffer of random noise
            const bufferSize = this.ctx.sampleRate * 0.5; // 0.5 seconds duration
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;

            // 2. Filter it (Lowpass) to make it sound muffled/distant
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(800, t);
            filter.frequency.exponentialRampToValueAtTime(100, t + 0.3); // Filter sweep down

            // 3. Amplitude Envelope (Fade out)
            const gain = this.ctx.createGain();
            gain.gain.setValueAtTime(0.15, t);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.4);

            // Connect nodes: Noise -> Filter -> Gain -> Output
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(this.ctx.destination);
            
            noise.start();
        },

        // Sound: "Score"
        // A pure Sine wave "ping" at a high frequency (A5 - 880Hz).
        // Used when passing obstacles.
        score: function() {
            if (!this.ctx) return;
            const t = this.ctx.currentTime;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(880, t); 
            
            // Short attack, long decay (bell-like envelope)
            gain.gain.setValueAtTime(0.0, t);
            gain.gain.linearRampToValueAtTime(0.08, t + 0.02); 
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);

            osc.connect(gain);
            gain.connect(this.ctx.destination);

            osc.start();
            osc.stop(t + 0.35);
        }
    };

    // --- GAME CONFIGURATION ---
    // Tweak these to change the feel of the physics
    const CONFIG = {
        gravity: -0.018,        // Downward force per frame
        jumpForceY: 0.32,       // Upward force on tap
        jumpForceX: 0.16,       // Sideways force on tap
        gapSize: 4.5,           // Width between obstacle blocks
        obstacleDistance: 7.0,  // Vertical distance between obstacles
        playerSize: 0.6         // Radius of the player object
    };

    // --- GAME STATE ---
    let state = {
        isPlaying: false,
        isDead: false,
        score: 0,
        time: 0,
        rotationSpeed: 1.0      // Visual rotation of the artifact
    };

    // --- THREE.JS SCENE SETUP ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    
    // Camera Setup
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 20); // Pull camera back to see the field

    // Renderer Setup
    const renderer = new THREE.WebGLRenderer({ antialias: false }); // Antialias off for performance with Bloom
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Cap pixel ratio for mobile performance
    container.appendChild(renderer.domElement);

    // --- POST PROCESSING (BLOOM) ---
    // This creates the "Neon" look by making bright pixels glow
    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight));
    bloomPass.strength = 0.6;   // Intensity of glow
    bloomPass.radius = 0.5;     // Spread of glow
    bloomPass.threshold = 0.15; // Only colors brighter than 0.15 will glow

    const composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    // --- LIGHTING ---
    const ambientLight = new THREE.AmbientLight(0x111111); // Dim global light
    scene.add(ambientLight);

    const pointLight = new THREE.PointLight(0xffffff, 1, 20); // Local light attached to player
    scene.add(pointLight); 

    // --- SHADERS (GLSL) ---
    
    // Shader 1: Background
    // Generates a deep space nebula effect using moving distance fields.
    // Why shader? It's faster than loading a large texture and infinitely scalable.
    const bgVertexShader = `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    const bgFragmentShader = `
        uniform float time;
        varying vec2 vUv;

        void main() {
            // Calculate 3 moving points
            vec2 p1 = vec2(0.5 + sin(time*0.1)*0.3, 0.5 + cos(time*0.15)*0.3);
            vec2 p2 = vec2(0.5 + sin(time*0.2 + 2.0)*0.4, 0.5 + cos(time*0.1 + 1.0)*0.4);
            vec2 p3 = vec2(0.5 + cos(time*0.05 + 4.0)*0.3, 0.5 + sin(time*0.15 + 3.0)*0.3);

            // Distance from UV to points
            float d1 = distance(vUv, p1);
            float d2 = distance(vUv, p2);
            float d3 = distance(vUv, p3);

            // Create soft blobs
            float b1 = smoothstep(0.8, 0.0, d1);
            float b2 = smoothstep(0.9, 0.0, d2);
            float b3 = smoothstep(0.8, 0.0, d3);

            // Deep space colors (Violet, Navy, Maroon)
            vec3 c1 = vec3(0.04, 0.01, 0.08); 
            vec3 c2 = vec3(0.01, 0.03, 0.06); 
            vec3 c3 = vec3(0.03, 0.00, 0.02); 
            vec3 base = vec3(0.0, 0.0, 0.01);
            
            // Mix colors based on blobs
            vec3 finalColor = base;
            finalColor += c1 * b1;
            finalColor += c2 * b2;
            finalColor += c3 * b3;
            
            // Vignette (Darken corners)
            finalColor *= 1.0 - smoothstep(0.2, 1.2, length(vUv - 0.5));

            gl_FragColor = vec4(finalColor, 1.0);
        }
    `;

    // Shader 2: Player Core
    // Generates the gradients and "scanlines" on the player object.
    const coreVertexShader = `
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vPosition;
        void main() {
            vUv = uv;
            vNormal = normal;
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    const coreFragmentShader = `
        uniform float time;
        varying vec3 vNormal;
        varying vec3 vPosition;

        void main() {
            // Cyan to Pink gradient
            vec3 c1 = vec3(0.1, 0.8, 0.9); 
            vec3 c2 = vec3(0.9, 0.1, 0.3); 
            
            // Gradient mix based on Y position and Time
            float mixVal = sin(vPosition.y * 3.0 + time * 2.0) * 0.5 + 0.5;
            
            // Scanline effect (horizontal bands)
            float scan = sin(vPosition.y * 20.0 - time * 5.0);
            scan = step(0.0, scan) * 0.1; // Make it sharp
            
            vec3 color = mix(c1, c2, mixVal) + vec3(scan);
            
            // Rim Lighting (Fresnel effect) - makes edges glow
            float rim = 1.0 - max(dot(vNormal, vec3(0,0,1)), 0.0);
            rim = pow(rim, 3.0);
            
            gl_FragColor = vec4(color + rim * 0.5, 0.9);
        }
    `;

    // --- GAME OBJECTS ---

    // 1. Background Plane
    // A large quad behind everything that displays the nebula shader
    const bgGeo = new THREE.PlaneGeometry(100, 100);
    const bgMat = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 } },
        vertexShader: bgVertexShader,
        fragmentShader: bgFragmentShader,
        depthWrite: false // Don't write to depth buffer so it stays behind everything
    });
    const bgMesh = new THREE.Mesh(bgGeo, bgMat);
    bgMesh.position.z = -50; 
    scene.add(bgMesh);

    // 2. Player Group (The "Artifact")
    // Consists of 3 parts: Core (Shader), Cage (Wireframe), Ring (Torus)
    const playerGroup = new THREE.Group();
    scene.add(playerGroup);

    // Part A: Inner Core
    const coreGeo = new THREE.OctahedronGeometry(CONFIG.playerSize * 0.7, 0);
    const coreMat = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 } },
        vertexShader: coreVertexShader,
        fragmentShader: coreFragmentShader,
        transparent: true
    });
    const coreMesh = new THREE.Mesh(coreGeo, coreMat);
    playerGroup.add(coreMesh);

    // Part B: Outer Wireframe Cage
    const cageGeo = new THREE.IcosahedronGeometry(CONFIG.playerSize, 0);
    const cageMat = new THREE.MeshBasicMaterial({ 
        color: 0xffffff, 
        wireframe: true,
        transparent: true,
        opacity: 0.3
    });
    const cageMesh = new THREE.Mesh(cageGeo, cageMat);
    playerGroup.add(cageMesh);

    // Part C: Rotating Ring
    const ringGeo = new THREE.TorusGeometry(CONFIG.playerSize * 1.2, 0.02, 8, 32);
    const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
    const ringMesh = new THREE.Mesh(ringGeo, ringMat);
    ringMesh.rotation.x = Math.PI / 2;
    playerGroup.add(ringMesh);

    let velocity = new THREE.Vector3(0, 0, 0);

    // 3. Obstacles
    // We pool obstacles in a group
    const obstacleGroup = new THREE.Group();
    scene.add(obstacleGroup);
    const obstacles = []; 

    // 4. Particles (Explosions/Thrusters)
    const particles = [];
    const particleGeo = new THREE.TetrahedronGeometry(0.15, 0);

    // --- LOGIC FUNCTIONS ---

    // Resets the game state (called on start and after death)
    function resetGame() {
        state.isPlaying = false;
        state.isDead = false;
        state.score = 0;
        state.rotationSpeed = 1.0;
        updateScoreUI();
        
        // Reset Player Physics
        playerGroup.position.set(0, 0, 0);
        playerGroup.visible = true;
        velocity.set(0, 0, 0);
        
        coreMesh.rotation.set(0,0,0);
        cageMesh.rotation.set(0,0,0);

        // Reset Camera & BG
        camera.position.y = 0;
        bgMesh.position.y = 0;

        // Clean up old obstacles
        while(obstacleGroup.children.length > 0){ 
            const obj = obstacleGroup.children[0];
            obj.geometry.dispose(); 
            obj.material.dispose();
            obstacleGroup.remove(obj); 
        }
        obstacles.length = 0;

        // Generate initial obstacles
        for(let i=1; i<6; i++) {
            createObstacle(i * CONFIG.obstacleDistance);
        }

        document.getElementById('start-text').style.display = 'block';
        document.getElementById('score').style.color = 'rgba(255,255,255,0.1)';
    }

    // Handles Game Start
    window.triggerStart = function() {
        Audio.init(); // Important: Audio context must resume on user gesture

        if (state.isPlaying) return;
        state.isPlaying = true;
        document.getElementById('start-text').style.display = 'none';
        document.getElementById('score').style.color = 'rgba(255,255,255,0.4)';
        jump(1); // Auto-jump on start
    };

    // Generates a row of obstacles with a gap
    function createObstacle(yPos) {
        // Random Neon Color
        const hues = [0xff0055, 0x00ffff, 0xaa00ff];
        const color = hues[Math.floor(Math.random() * hues.length)];

        const material = new THREE.MeshStandardMaterial({ 
            color: 0x000000, 
            emissive: color,
            emissiveIntensity: 1.2, // Makes it glow with Bloom
            roughness: 0.1,
            metalness: 0.9
        });
        
        const gapX = (Math.random() * 6) - 3; 
        const leftEdge = -6;
        const rightEdgeOfLeftBlock = gapX - (CONFIG.gapSize / 2);
        const leftWidth = rightEdgeOfLeftBlock - leftEdge;
        
        // Left Block
        if (leftWidth > 0) {
            const leftGeo = new THREE.BoxGeometry(leftWidth, 0.5, 1);
            const leftMesh = new THREE.Mesh(leftGeo, material);
            leftMesh.position.set(leftEdge + (leftWidth/2), yPos, 0);
            obstacleGroup.add(leftMesh);
            obstacles.push({ mesh: leftMesh });
        }

        // Right Block
        const rightEdge = 6;
        const leftEdgeOfRightBlock = gapX + (CONFIG.gapSize / 2);
        const rightWidth = rightEdge - leftEdgeOfRightBlock;

        if (rightWidth > 0) {
            const rightGeo = new THREE.BoxGeometry(rightWidth, 0.5, 1);
            const rightMesh = new THREE.Mesh(rightGeo, material);
            rightMesh.position.set(rightEdge - (rightWidth/2), yPos, 0);
            obstacleGroup.add(rightMesh);
            obstacles.push({ mesh: rightMesh });
        }
    }

    // Applies forces to player
    function jump(direction) {
        if(state.isDead) return;

        // No audio on jump (Subtle design choice)

        velocity.y = CONFIG.jumpForceY;
        velocity.x = direction * CONFIG.jumpForceX;
        state.rotationSpeed = 6.0; // Spin up on jump

        spawnParticles(8, playerGroup.position);
    }

    // Creates particle debris
    function spawnParticles(count, pos) {
        if (particles.length > 100) return; // Limit total particles for performance

        for(let i=0; i<count; i++) {
            const mat = new THREE.MeshBasicMaterial({ 
                color: Math.random() > 0.5 ? 0x00ffff : 0xff00aa,
                wireframe: true
            });
            const mesh = new THREE.Mesh(particleGeo, mat);
            
            // Random position offset
            mesh.position.copy(pos).add(new THREE.Vector3(
                (Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5)
            ));
            
            mesh.rotation.set(Math.random()*6, Math.random()*6, Math.random()*6);
            scene.add(mesh);
            
            particles.push({
                mesh: mesh,
                life: 1.0,
                velocity: new THREE.Vector3(
                    (Math.random()-0.5)*0.3, 
                    (Math.random()-0.5)*0.3,
                    (Math.random()-0.5)*0.3
                ),
                rotVel: new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5)
            });
        }
    }

    // Death Visuals
    function shatterPlayer() {
        playerGroup.visible = false;
        spawnParticles(40, playerGroup.position);
    }

    // Collision Detection (AABB)
    function checkCollisions() {
        if(state.isDead) return false;

        const playerBox = new THREE.Box3().setFromObject(coreMesh);
        // Shrink hitbox slightly to be forgiving
        playerBox.min.addScalar(0.15);
        playerBox.max.addScalar(-0.15);

        // Wall check
        if (playerGroup.position.x < -6.5 || playerGroup.position.x > 6.5) return true;

        // Obstacle check
        for (let obs of obstacles) {
            const obsBox = new THREE.Box3().setFromObject(obs.mesh);
            if (playerBox.intersectsBox(obsBox)) return true;
        }
        
        // Floor check (fall death)
        if (playerGroup.position.y < camera.position.y - 8) return true;

        return false;
    }

    function gameOver() {
        state.isDead = true;
        Audio.crash(); 
        shatterPlayer();
        setTimeout(() => { resetGame(); }, 1500);
    }

    function updateScoreUI() {
        const scoreEl = document.getElementById('score');
        scoreEl.innerText = state.score;
        scoreEl.style.transform = "scale(1.2)";
        setTimeout(() => scoreEl.style.transform = "scale(1)", 100);
    }

    // --- MAIN GAME LOOP (ANIMATION) ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);

        const delta = clock.getDelta();
        state.time += delta;
        
        // Update Shaders
        coreMat.uniforms.time.value = state.time;
        bgMat.uniforms.time.value = state.time;

        if (state.isPlaying && !state.isDead) {
            // 1. Apply Physics
            velocity.y += CONFIG.gravity;
            playerGroup.position.add(velocity);

            // 2. Rotate Player Parts
            state.rotationSpeed += (1.0 - state.rotationSpeed) * 3.0 * delta; // Dampen rotation
            
            coreMesh.rotation.y += delta * state.rotationSpeed;
            coreMesh.rotation.x += delta * state.rotationSpeed * 0.5;
            cageMesh.rotation.y -= delta * state.rotationSpeed * 0.8;
            cageMesh.rotation.z += delta * state.rotationSpeed * 0.2;
            ringMesh.rotation.x = (Math.PI / 2) + Math.sin(state.time * 2) * 0.2;
            ringMesh.rotation.y = state.time;

            // 3. Move Camera & Background (Parallax)
            const targetCamY = playerGroup.position.y + 3;
            if (targetCamY > camera.position.y) {
                 camera.position.y += (targetCamY - camera.position.y) * 0.1;
                 bgMesh.position.y = camera.position.y;
            }
            // Move light with player
            pointLight.position.set(playerGroup.position.x, playerGroup.position.y + 2, 5);

            // 4. Scoring & Level Generation
            const expectedScore = Math.floor(playerGroup.position.y / CONFIG.obstacleDistance);
            if (expectedScore > state.score) {
                state.score = expectedScore;
                Audio.score(); // Sound on score
                updateScoreUI();
                createObstacle((state.score + 5) * CONFIG.obstacleDistance);
            }

            // 5. Cleanup Old Obstacles
            if (obstacles.length > 15) {
                const old = obstacles.shift();
                old.mesh.geometry.dispose();
                old.mesh.material.dispose();
                obstacleGroup.remove(old.mesh); 
            }

            // 6. Check Death
            if (checkCollisions()) gameOver();

        } else if (!state.isPlaying) {
            // Idle Animation (Floating)
            playerGroup.position.y = Math.sin(state.time * 1.5) * 0.3;
            coreMesh.rotation.y += delta;
            cageMesh.rotation.y -= delta;
        }

        // 7. Update Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.life -= delta * 1.5;
            p.mesh.position.add(p.velocity);
            p.mesh.rotation.x += p.rotVel.x * 0.2;
            p.mesh.rotation.y += p.rotVel.y * 0.2;
            p.mesh.scale.setScalar(p.life);
            
            if (p.life <= 0) {
                p.mesh.geometry.dispose();
                p.mesh.material.dispose();
                scene.remove(p.mesh);
                particles.splice(i, 1);
            }
        }
        
        // 8. Render Scene with Post-Processing
        composer.render();
    }

    // --- INPUT HANDLING ---
    
    // Handles both Mouse and Touch inputs
    function handleTouch(e) {
        if (state.isDead) return;
        
        // Prevent default browser behavior (scrolling/zooming)
        if(e.type === 'touchstart') e.preventDefault(); 

        if (!state.isPlaying) {
            triggerStart();
            return;
        }

        const halfWidth = window.innerWidth / 2;

        // Multi-touch handling: Iterate through all changed touches
        if (e.changedTouches) {
            for (let i = 0; i < e.changedTouches.length; i++) {
                const x = e.changedTouches[i].clientX;
                if (x < halfWidth) jump(-1); // Left side -> Jump Left
                else jump(1);                // Right side -> Jump Right
            }
        } else {
            // Mouse handling
            if (e.clientX < halfWidth) jump(-1);
            else jump(1);
        }
    }

    // Attach listeners
    window.addEventListener('mousedown', handleTouch);
    window.addEventListener('touchstart', handleTouch, {passive: false});

    // Handle Window Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start Loop
    resetGame();
    animate();

</script>
</body>
</html>
